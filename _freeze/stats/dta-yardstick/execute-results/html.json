{
  "hash": "8e62b3e6f525ec22f128295f28becc21",
  "result": {
    "markdown": "---\ntitle: \"DTA (Yardstick)\"\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(yardstick)\n#> \n#> Attaching package: 'yardstick'\n#> The following object is masked from 'package:readr':\n#> \n#>     spec\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"pathology\")\nglimpse(pathology)\n#> Rows: 344\n#> Columns: 2\n#> $ pathology <fct> abnorm, abnorm, abnorm, abnorm, abnorm, abnorm, abnorm, abno…\n#> $ scan      <fct> abnorm, abnorm, abnorm, abnorm, abnorm, abnorm, abnorm, abno…\n```\n:::\n\n\n## Confusion Matric\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncm <- conf_mat(pathology, truth = pathology, estimate = scan) \ncm\n#>           Truth\n#> Prediction abnorm norm\n#>     abnorm    231   32\n#>     norm       27   54\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(cm)\n#> # A tibble: 13 × 3\n#>    .metric              .estimator .estimate\n#>    <chr>                <chr>          <dbl>\n#>  1 accuracy             binary         0.828\n#>  2 kap                  binary         0.534\n#>  3 sens                 binary         0.895\n#>  4 spec                 binary         0.628\n#>  5 ppv                  binary         0.878\n#>  6 npv                  binary         0.667\n#>  7 mcc                  binary         0.534\n#>  8 j_index              binary         0.523\n#>  9 bal_accuracy         binary         0.762\n#> 10 detection_prevalence binary         0.765\n#> 11 precision            binary         0.878\n#> 12 recall               binary         0.895\n#> 13 f_meas               binary         0.887\n```\n:::\n\n\n\n## Plot Bar Chart\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(cm, type = \"mosaic\")\n```\n\n::: {.cell-output-display}\n![](dta-yardstick_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(cm, type = \"heatmap\")\n```\n\n::: {.cell-output-display}\n![](dta-yardstick_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npathology_cell <- pathology |> \n  count(pathology, scan) |> \n  mutate(prop = n/sum(n))\n\npathology_cell\n#>   pathology   scan   n       prop\n#> 1    abnorm abnorm 231 0.67151163\n#> 2    abnorm   norm  27 0.07848837\n#> 3      norm abnorm  32 0.09302326\n#> 4      norm   norm  54 0.15697674\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npathology_cell |> \n  ggplot(aes(pathology, prop, fill = scan, color = scan)) +\n  geom_col(alpha = 0.5, position = \"fill\")\n```\n\n::: {.cell-output-display}\n![](dta-yardstick_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n## Metric: Default\n\n\n::: {.cell}\n\n```{.r .cell-code}\npathology |> metrics(truth = pathology, estimate = scan)\n#> # A tibble: 2 × 3\n#>   .metric  .estimator .estimate\n#>   <chr>    <chr>          <dbl>\n#> 1 accuracy binary         0.828\n#> 2 kap      binary         0.534\n```\n:::\n\n\n## Metric Set\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_metrics_1 <- metric_set(accuracy, sens, spec, ppv, npv)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npathology |> class_metrics_1(truth = pathology, estimate = scan)\n#> # A tibble: 5 × 3\n#>   .metric  .estimator .estimate\n#>   <chr>    <chr>          <dbl>\n#> 1 accuracy binary         0.828\n#> 2 sens     binary         0.895\n#> 3 spec     binary         0.628\n#> 4 ppv      binary         0.878\n#> 5 npv      binary         0.667\n```\n:::\n\n\n## Custom Class Metric\n\n[Miss Rate Example](https://www.tidymodels.org/learn/develop/metrics/#class-example-miss-rate)\n\n\n## Custom LR+ & LR-\n\nFrom: [How to implemen custom metric set](https://www.tidymodels.org/learn/develop/metrics/#class-example-miss-rate)\n\n### Formular\n\nThe **positive** likelihood ratio is calculated as:\n\n$$\n{\\displaystyle {\\text{LR}}+={\\frac {\\text{sensitivity}}{1-{\\text{specificity}}}}}\n$$\n\n\n$$\n{\\displaystyle {\\text{LR}}+={\\frac {\\text{TP / (TP + FN)}}{\\text{FP / (FP + TN)}}}}\n$$\n\nThe **negative** likelihood ratio is calculated as:\n\n\n$$\n{\\displaystyle {\\text{LR}}-={\\frac {1-{\\text{sensitivity}}}{\\text{specificity}}}}\n$$\n\n$$\n{\\displaystyle {\\text{LR}}-={\\frac {\\text{FN / (TP + FN)}}{\\text{TN / (FP + TN)}}}}\n$$\n\n### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\npathology_xtab <- table(pathology$scan, pathology$pathology) \npathology_xtab\n#>         \n#>          abnorm norm\n#>   abnorm    231   32\n#>   norm       27   54\n```\n:::\n\n\n\n### Helpers\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Logic for `event_level`\nevent_col <- function(xtab, event_level) {\n  if (identical(event_level, \"first\")) {\n    colnames(xtab)[[1]]\n  } else {\n    colnames(xtab)[[2]]\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfinalize_estimator_internal.lr_pos <- function(metric_dispatcher, x, estimator, call) {\n  \n  validate_estimator(estimator, estimator_override = \"binary\")\n  if (!is.null(estimator)) {\n    return(estimator)\n  }\n  \n  lvls <- levels(x)\n  if (length(lvls) > 2) {\n    stop(\"A multiclass `truth` input was provided, but only `binary` is supported.\")\n  } \n  \"binary\"\n}\n```\n:::\n\n\n### Implement\n\n#### LR Pos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_pos_impl <- function(truth, estimate, estimator, event_level) {\n  xtab <- table(estimate, truth)\n  # Rather than implement the actual method here, we rely on\n  # an *_estimator_impl() function that can handle binary\n  # and multiclass cases\n  lr_pos_estimator_impl(xtab, estimator, event_level)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function switches between binary and multiclass implementations\nlr_pos_estimator_impl <- function(data, estimator, event_level) {\n  if(estimator == \"binary\") {\n    lr_pos_binary(data, event_level)\n  } else {\n    # Encapsulates the macro, macro weighted, and micro cases\n    # TODO\n  }\n}\n```\n:::\n\n\n#### LR Neg\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_neg_impl <- function(truth, estimate, estimator, event_level) {\n  xtab <- table(estimate, truth)\n  # Rather than implement the actual method here, we rely on\n  # an *_estimator_impl() function that can handle binary\n  # and multiclass cases\n  lr_neg_estimator_impl(xtab, estimator, event_level)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function switches between binary and multiclass implementations\nlr_neg_estimator_impl <- function(data, estimator, event_level) {\n  if(estimator == \"binary\") {\n    lr_neg_binary(data, event_level)\n  } else {\n    # Encapsulates the macro, macro weighted, and micro cases\n    # TODO\n  }\n}\n```\n:::\n\n\n\n### Binary Implementation\n\n#### LR Pos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_pos_binary <- function(data, event_level) {\n  col <- event_col(data, event_level)\n  col2 <- setdiff(colnames(data), col)\n  \n  tp <- data[col, col]\n  tn <- data[col2, col2]\n  fp <- data[col, col2]\n  fn <- data[col2, col]\n  # list(tp = tp, tn = tn, fp = fp, fn = fn)\n  (tp / (tp + fn)) / (fp / (fp + tn))\n  \n}\n\nlr_pos_binary(pathology_xtab, event_level = \"first\")\n#> [1] 2.40625\n```\n:::\n\n\n#### LR Neg\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_neg_binary <- function(data, event_level) {\n  col <- event_col(data, event_level)\n  col2 <- setdiff(colnames(data), col)\n  \n  tp <- data[col, col]\n  tn <- data[col2, col2]\n  fp <- data[col, col2]\n  fn <- data[col2, col]\n  # list(tp = tp, tn = tn, fp = fp, fn = fn)\n  (fn / (tp + fn)) / (tn / (fp + tn))\n  \n}\n\nlr_neg_binary(pathology_xtab, event_level = \"first\")\n#> [1] 0.1666667\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Checking\npathology_xtab\n#>         \n#>          abnorm norm\n#>   abnorm    231   32\n#>   norm       27   54\ncolnames(pathology_xtab)\n#> [1] \"abnorm\" \"norm\"\n\n# TP\npathology_xtab[\"abnorm\", \"abnorm\"]\n#> [1] 231\n# TN\npathology_xtab[\"norm\", \"norm\"]\n#> [1] 54\n# FP\npathology_xtab[\"abnorm\", \"norm\"]\n#> [1] 32\n# FN\npathology_xtab[\"norm\", \"abnorm\"]\n#> [1] 27\n```\n:::\n\n\n### Multiclass Implementation\n\n[TODO]\n\n### Vec implement\n\n\n#### LR Pos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_pos_vec <- function(truth,\n                       estimate,\n                       estimator = NULL,\n                       na_rm = TRUE,\n                       case_weights = NULL,\n                       event_level = \"first\",\n                       ...) {\n  # calls finalize_estimator_internal() internally\n  estimator <- finalize_estimator(truth, estimator, metric_class = \"lr_pos\")\n\n  check_class_metric(truth, estimate, case_weights, estimator)\n\n  if (na_rm) {\n    result <- yardstick_remove_missing(truth, estimate, case_weights)\n\n    truth <- result$truth\n    estimate <- result$estimate\n    case_weights <- result$case_weights\n  } else if (yardstick_any_missing(truth, estimate, case_weights)) {\n    return(NA_real_)\n  }\n\n  lr_pos_impl(truth, estimate, estimator, event_level)\n}\n\nlr_pos_vec(pathology$pathology, pathology$scan)\n#> [1] 2.40625\n```\n:::\n\n\n#### LR Neg\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_neg_vec <- function(truth,\n                       estimate,\n                       estimator = NULL,\n                       na_rm = TRUE,\n                       case_weights = NULL,\n                       event_level = \"first\",\n                       ...) {\n  # calls finalize_estimator_internal() internally\n  estimator <- finalize_estimator(truth, estimator, metric_class = \"lr_neg\")\n\n  check_class_metric(truth, estimate, case_weights, estimator)\n\n  if (na_rm) {\n    result <- yardstick_remove_missing(truth, estimate, case_weights)\n\n    truth <- result$truth\n    estimate <- result$estimate\n    case_weights <- result$case_weights\n  } else if (yardstick_any_missing(truth, estimate, case_weights)) {\n    return(NA_real_)\n  }\n\n  lr_neg_impl(truth, estimate, estimator, event_level)\n}\n\nlr_neg_vec(pathology$pathology, pathology$scan)\n#> [1] 0.1666667\n```\n:::\n\n\n\n### DF implement\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# LR Pos\nlr_pos <- function(data, ...) {\n  UseMethod(\"lr_pos\")\n}\n\nlr_pos <- new_class_metric(lr_pos, direction = \"maximize\")\n\n# LR Neg\nlr_neg <- function(data, ...) {\n  UseMethod(\"lr_neg\")\n}\n\nlr_neg <- new_class_metric(lr_neg, direction = \"minimize\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_pos.data.frame <- function(data,\n                              truth,\n                              estimate,\n                              estimator = NULL,\n                              na_rm = TRUE,\n                              case_weights = NULL,\n                              event_level = \"first\",\n                              ...) {\n  class_metric_summarizer(\n    name = \"lr_pos\",\n    fn = lr_pos_vec,\n    data = data,\n    truth = !!rlang::enquo(truth),\n    estimate = !!rlang::enquo(estimate),\n    estimator = estimator,\n    na_rm = na_rm,\n    case_weights = !!rlang::enquo(case_weights),\n    event_level = event_level\n  )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_neg.data.frame <- function(data,\n                              truth,\n                              estimate,\n                              estimator = NULL,\n                              na_rm = TRUE,\n                              case_weights = NULL,\n                              event_level = \"first\",\n                              ...) {\n  class_metric_summarizer(\n    name = \"lr_neg\",\n    fn = lr_neg_vec,\n    data = data,\n    truth = !!rlang::enquo(truth),\n    estimate = !!rlang::enquo(estimate),\n    estimator = estimator,\n    na_rm = na_rm,\n    case_weights = !!rlang::enquo(case_weights),\n    event_level = event_level\n  )\n}\n```\n:::\n\n\n\n### Using `lr_pos()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_pos(pathology, truth = pathology, estimate = scan)\n#> # A tibble: 1 × 3\n#>   .metric .estimator .estimate\n#>   <chr>   <chr>          <dbl>\n#> 1 lr_pos  binary          2.41\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_pos_vec(truth = pathology$pathology, estimate = pathology$scan)\n#> [1] 2.40625\n```\n:::\n\n\n### Using `lr_neg()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_neg(pathology, truth = pathology, estimate = scan)\n#> # A tibble: 1 × 3\n#>   .metric .estimator .estimate\n#>   <chr>   <chr>          <dbl>\n#> 1 lr_neg  binary         0.167\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlr_neg_vec(truth = pathology$pathology, estimate = pathology$scan)\n#> [1] 0.1666667\n```\n:::\n\n\n### Using with `metric_set()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_metrics_2 <- metric_set(accuracy, sens, spec, lr_pos, lr_neg)\nclass_metrics_2\n#> # A tibble: 5 × 3\n#>   metric   class        direction\n#>   <chr>    <chr>        <chr>    \n#> 1 accuracy class_metric maximize \n#> 2 sens     class_metric maximize \n#> 3 spec     class_metric maximize \n#> 4 lr_pos   class_metric maximize \n#> 5 lr_neg   class_metric minimize\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nconf_mat(pathology, truth = pathology, estimate = scan)\n#>           Truth\n#> Prediction abnorm norm\n#>     abnorm    231   32\n#>     norm       27   54\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_metrics_2(pathology, truth = pathology, estimate = scan)\n#> # A tibble: 5 × 3\n#>   .metric  .estimator .estimate\n#>   <chr>    <chr>          <dbl>\n#> 1 accuracy binary         0.828\n#> 2 sens     binary         0.895\n#> 3 spec     binary         0.628\n#> 4 lr_pos   binary         2.41 \n#> 5 lr_neg   binary         0.167\n```\n:::\n\n\nCheck LR+\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0.8953488\t/ (1 - 0.6279070) # LR+ = Sens / (1-Spec)\n#> [1] 2.40625\n```\n:::\n\n\nCheck LR-\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(1 - 0.8953488)\t/ 0.6279070\t # LR- = (1-Sens) / Spec\n#> [1] 0.1666667\n```\n:::\n",
    "supporting": [
      "dta-yardstick_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}